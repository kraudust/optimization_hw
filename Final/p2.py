import numpy as np
from scipy import interpolate
from pyoptwrapper import optimize
from pyoptsparse import SNOPT, NSGA2


def func(x):
    x1 = x[0]*1000.
    x2 = x[1]
    x3 = x[2]

    Z = np.array([0.4353, 0.6916, 0.7394, 0.7532, 0.7559, 0.7610, 0.7619, 0.7622, 0.7623, 0.7571, 0.7510, 0.7468, 0.7456, 0.4147, 0.6784, 0.7406, 0.7628, 0.7676, 0.7752, 0.7766, 0.7773, 0.7776, 0.7771, 0.7716, 0.7641, 0.7579, 0.3649, 0.6507, 0.7214, 0.7517, 0.7617, 0.7801, 0.7842, 0.7868, 0.7888, 0.7992, 0.8071, 0.8132, 0.8152, 0.2917, 0.5974, 0.6868, 0.7359, 0.7530, 0.7899, 0.7954, 0.7985, 0.8005, 0.8065, 0.8103, 0.8147, 0.8177, 0.3207, 0.6032, 0.6824, 0.7267, 0.7421, 0.7813, 0.7885, 0.7925, 0.7952, 0.8033, 0.8068, 0.8097, 0.8100, 0.2553, 0.5641, 0.6628, 0.7205, 0.7399, 0.7971, 0.8109, 0.8177, 0.8216, 0.8314, 0.8327, 0.8299, 0.8259, 0.2093, 0.5049, 0.6083, 0.6760, 0.7029, 0.7778, 0.7992, 0.8094, 0.8155, 0.8327, 0.8401, 0.8450, 0.8438, 0.2262, 0.5081, 0.6171, 0.6845, 0.7029, 0.7630, 0.7866, 0.8041, 0.8146, 0.8413, 0.8544, 0.8751, 0.8993, 0.1529, 0.5149, 0.6536, 0.7404, 0.7701, 0.8489, 0.8717, 0.8885, 0.9010, 0.9294, 0.9363, 0.9379, 0.9293, 0.0559, 0.3642, 0.5194, 0.6368, 0.6826, 0.8110, 0.8483, 0.8764, 0.8979, 0.9506, 0.9584, 0.9615, 0.9609, 0.0678, 0.2188, 0.3128, 0.3968, 0.4331, 0.5504, 0.5898, 0.6162, 0.6375, 0.7029, 0.7174, 0.7282, 0.7315])
    X = np.array([800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 800, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1250, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1500, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 1750, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2000, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2250, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 2750, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 3500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 4500, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000, 6000])
    Y = np.array([0.1246, 0.3118, 0.4980, 0.6947, 0.7607, 0.9007, 0.9287, 0.9438, 0.9526, 0.9702, 0.9756, 0.9794, 0.9809, 0.1062, 0.2547, 0.3964, 0.5840, 0.6645, 0.8515, 0.8929, 0.9160, 0.9299, 0.9560, 0.9625, 0.9684, 0.9719, 0.0976, 0.2141, 0.3291, 0.4777, 0.5593, 0.7868, 0.8436, 0.8767, 0.8974, 0.9397, 0.9480, 0.9537, 0.9567, 0.0989, 0.1968, 0.2911, 0.4099, 0.4748, 0.7169, 0.7880, 0.8318, 0.8601, 0.9219, 0.9345, 0.9413, 0.9440, 0.0871, 0.1702, 0.2542, 0.3618, 0.4201, 0.6651, 0.7449, 0.7959, 0.8294, 0.9043, 0.9200, 0.9291, 0.9332, 0.0839, 0.1545, 0.2223, 0.3136, 0.3624, 0.5908, 0.6818, 0.7413, 0.7821, 0.8771, 0.8979, 0.9105, 0.9163, 0.0888, 0.1537, 0.2159, 0.2968, 0.3400, 0.5404, 0.6369, 0.7007, 0.7454, 0.8543, 0.8781, 0.8917, 0.8982, 0.0815, 0.1338, 0.1824, 0.2454, 0.2845, 0.4603, 0.5527, 0.6245, 0.6744, 0.8058, 0.8347, 0.8470, 0.8486, 0.0648, 0.0995, 0.1328, 0.1765, 0.2014, 0.3266, 0.3957, 0.4618, 0.5233, 0.7003, 0.7434, 0.7679, 0.7806, 0.0727, 0.1019, 0.1285, 0.1598, 0.1762, 0.2631, 0.3143, 0.3606, 0.4043, 0.5885, 0.6342, 0.6582, 0.6674, 0.1155, 0.1405, 0.1642, 0.1928, 0.2083, 0.2882, 0.3371, 0.3832, 0.4263, 0.5948, 0.6345, 0.6530, 0.6608])

    Xeval = np.linspace(1000, 6000, 300)
    Yeval = np.linspace(0.0, 1, 300)
    xx, yy = np.meshgrid(Xeval, Yeval)
    zz = interpolate.griddata((X, Y), Z, (xx, yy), method='cubic')
    zz[np.isnan(zz)] = 0.0

    feval = interpolate.RectBivariateSpline(Xeval, Yeval, zz)
    f = feval(x1, x2*x3)

    f = f - 0.01*((x2 + 2*x3 - 7)**2 + (2*x3 + x3 - 5)**2)
    c1 = x1/1000.0 + x2 + 5.0*x3**2 - 9.0 #less than or equal to zero
    c = np.array([c1])

    return -f, c

if __name__ == '__main__':

    #x0 = np.array([1.5, 0.5, 0.25])
    #x0 = np.array([5.9, 0.1, 0.1])
    x0 = np.array([3.0, 0.9, 0.9])
    f0 = func(x0)[0]
    lb = np.array([1.0, 0.0, 0.0])
    ub = np.array([6.0, 1.0, 1.0])

    #Run Optimization
    optimizer = SNOPT()
    xopt, fopt, info = optimize(func, x0, lb, ub, optimizer)

    #rescale the design variables
    x0[0] = x0[0]*1000.
    xopt[0] = xopt[0]*1000.

    #print results
    print "x0: ", x0
    print "f0: ", -f0
    print "xopt: ", xopt
    print "fopt: ", -fopt

#------------------------------Answers-------------------------------------
#1. Answer: xopt = [3864.89  0.6839  0.9435]
#           fopt = 0.71941002
#2. Description of the how and why of your approach:
#       First, I put the constraint into the objective function (func) as
#       this is the format that the pyoptwrapper expects. Then because this
#       is a maximization problem, and the pyoptwrapper (which references
#       pyopsparse) minimizes problems, I multiplied the function value by
#       -1. Minimizing the negative function value is the same as
#       maximizing the function. I used the optimizer SNOPT in pyoptsparse
#       as it is a good gradient based optimizer. I used multiple different
#       starting points to verify that the answer I got was correct. Also,
#       I scaled all of the design variables to be of the same order.
#--------------------------------------------------------------------------
